package App::Exobrain;

use v5.010;
use strict;
use warnings;
use autodie;
use Moose;
use Method::Signatures;
use Carp qw(croak);

# ABSTRACT: Core Exobrain accessor class

# VERSION: Generated by DZP::OurPkg:Version

use App::Exobrain::Bus;
use App::Exobrain::Config;
use App::Exobrain::Message;
use App::Exobrain::Message::Raw;

has 'config' => (
    is => 'ro',
    isa => 'App::Exobrain::Config',
    builder => '_build_config',
);

# Pub/Sub interfaces to our bus. These don't get generated unless
# our end code actually asks for them. Many things will only require
# one, or will use higher-level functions to do their work.

has 'pub' => (
    is => 'ro',
    isa => 'App::Exobrain::Bus',
    builder => '_build_pub',
    lazy => 1,
);

has 'sub' => (
    is => 'ro',
    isa => 'App::Exobrain::Bus',
    builder => '_build_sub',
    lazy => 1,
);

sub _build_config { return App::Exobrain::Config->new; };
sub _build_pub    { return App::Exobrain::Bus->new(type => 'PUB', exobrain => shift) }
sub _build_sub    { return App::Exobrain::Bus->new(type => 'SUB', exobrain => shift) }

=method watch_loop

    $exobrain->watch_loop(
        class  => 'Measurement::Geo',
        filter => sub { $_->is_me },
        then   => sub { ... },
    );

When we see packets of a particular class, do a particular thing.

Never returns, just runs the loop forever.

=cut

method watch_loop(
    Str     :$class!,
    CodeRef :$filter,
    CodeRef :$then!,
) {

    # Load our component, because that means we immediately get
    # an error if that class doesn't exist.

    $self->_load_component($class);

    while (my $event = $self->sub->get) {
        next unless $event->namespace eq $class;

        $event = $event->to_class($class);

        if ($filter) {

            # Check our filter, and skip if required
            local $_ = $event;
            next unless $filter->();

        }

        # Everything passes! Trigger our callback
        $then->($event);
    }
}

=method message

    $exobrain->message( ... )->send_msg;

Shortcut to create a 'raw' message. The exobrain parameter will be passed
to the class constructor automatically.

=cut

method message(@args) {
    return App::Exobrain::Message::Raw->new(
        exobrain => $self,
        @args,
    );
}

method message_class($class, @args) {
    $class = $self->_load_component($class);

    return $class->new(
        exobrain => $self,
        @args,
    );
}

=method measure

    $exobrain->measure( 'Mailbox',
        count  => 42,
        user   => 'pjf',
        server => 'imap.example.com',
        fodler => 'INBOX',
    )->send;

Preferred shortcut for creating a measurement of the desired class. The
C<exobrain> parameter will be passed to the measurement class constructor
automatically.

=cut

use constant MEASURE_PREFIX => 'Measurement::';

method measure($type, @args) {

    my $class = $self->_load_component( MEASURE_PREFIX . $type );

    return $class->new(
        exobrain => $self,
        @args,
    );
}

=method intent

    my $intent = $exobrain->intent( 'Tweet',
        tweet => 'Hello World',
    );

Preferred shortcut for making an intent of the desired class. The
C<exobrain> parameter will be passed to the intent class constructor
automatically.

=cut

use constant INTENT_PREFIX => 'Intent::';

method intent($type, @args) {
    my $class = $self->_load_component( INTENT_PREFIX . $type );

    return $class->new(
        exobrain => $self,
        @args,
    );
}

use constant CLASS_PREFIX => 'App::Exobrain::';

# Loads a class, automatically adding App::Exobrain if
# required. Returns the class loaded.

method _load_component(Str $class) {
    $class = CLASS_PREFIX . $class;

    eval "require $class";
    croak $@ if $@;

    return $class;
}

=for Pod::Coverage BUILD DEMOLISH

=cut

1;
